<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commentree - Force Wrap</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #f9f9f9; font-family: 'Helvetica Neue', Arial, sans-serif; }
        
        header { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; }
        h1 { margin: 0; font-size: 1.5rem; color: #000; }
        p { color: #666; font-size: 0.9rem; margin-top: 5px; }

        #inputModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); z-index: 100; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 20px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); text-align: center; width: 300px; }
        input[type="text"] { width: 80%; padding: 10px; margin: 15px 0; border: 1px solid #ddd; border-radius: 5px; }
        button { padding: 8px 20px; background: #000; color: white; border: none; border-radius: 20px; cursor: pointer; font-weight: bold; }
        button:hover { background: #333; }

        /* [핵심 수정] 텍스트 강제 줄바꿈 스타일 */
        .bubble-text {
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            width: 100%;
            height: 100%;
            
            /* 어떤 상황에서도 줄바꿈이 일어나도록 설정 */
            white-space: normal;       
            word-wrap: break-word;     
            overflow-wrap: break-word; 
            word-break: break-all;     /* 띄어쓰기가 없는 긴 단어도 강제로 자름 */
            
            line-height: 1.2;
            overflow: hidden;
            padding: 0px; 
            box-sizing: border-box;
        }
    </style>
</head>
<body>

    <header>
        <h1>Commentree</h1>
        <p>어떤 내용도 말풍선 안에 맞춰집니다.</p>
    </header>

    <div id="chart"></div>

    <div id="inputModal">
        <div class="modal-content">
            <h3>댓글 남기기</h3>
            <input type="text" id="commentInput" placeholder="내용을 입력하세요" maxlength="50">
            <br>
            <button onclick="submitComment()">등록</button>
            <button onclick="closeModal()" style="background:#999">취소</button>
        </div>
    </div>

    <script>
        // --- 1. 데이터 초기화 ---
        let dataset = {
            nodes: [
                { id: "root", label: "여기를 눌러\n시작하세요", color: "#000000", radius: 60, x: window.innerWidth/2, y: window.innerHeight/2, phase: Math.random() * Math.PI * 2 }
            ],
            links: []
        };

        const width = window.innerWidth;
        const height = window.innerHeight;
        let selectedNode = null;

        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(d3.zoom().on("zoom", (event) => {
                g.attr("transform", event.transform);
            }))
            .append("g");

        const g = svg.append("g");
        const linkLayer = g.append("g").attr("class", "links");
        const nodeLayer = g.append("g").attr("class", "nodes");

        const simulation = d3.forceSimulation(dataset.nodes)
            .force("link", d3.forceLink(dataset.links).id(d => d.id).distance(110))
            .force("charge", d3.forceManyBody().strength(-450)) 
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide().radius(d => d.radius + 10).iterations(3));

        function update() {
            const link = linkLayer.selectAll(".link")
                .data(dataset.links)
                .join("line")
                .attr("class", "link")
                .attr("stroke", "#bbb") 
                .attr("stroke-width", 2);

            const node = nodeLayer.selectAll(".node")
                .data(dataset.nodes, d => d.id)
                .join("g")
                .attr("class", "node")
                .call(drag(simulation));

            // 원 그리기
            node.selectAll("circle").remove();
            node.append("circle")
                .attr("r", d => d.radius)
                .attr("fill", d => d.color) 
                .attr("stroke", "#000") 
                .attr("stroke-width", 2)
                .style("cursor", "pointer")
                .style("filter", "drop-shadow(0px 3px 3px rgba(0,0,0,0.1))")
                .on("click", (event, d) => {
                    event.stopPropagation();
                    openModal(d);
                });

            // 텍스트 박스 (foreignObject)
            node.selectAll("foreignObject").remove();
            node.append("foreignObject")
                // 텍스트 박스 크기를 원 안에 꽉 차게 설정 (반지름 * 1.4 정도가 정사각형 내접)
                .attr("width", d => d.radius * 1.6) 
                .attr("height", d => d.radius * 1.6)
                .attr("x", d => -d.radius * 0.8) 
                .attr("y", d => -d.radius * 0.8)
                .style("pointer-events", "none") 
                .append("xhtml:div")
                .attr("class", "bubble-text")
                .style("color", d => d.color === "#000000" ? "#fff" : "#000")
                .style("font-weight", "bold")
                // 폰트 크기: 글자가 잘리지 않도록 조금 더 작게 조정 (최소 12px)
                .style("font-size", d => Math.max(12, d.radius / 5) + "px")
                .html(d => d.label);

            simulation.on("tick", () => {
                const time = Date.now() / 1000; 
                node.attr("transform", d => {
                    const floatingY = Math.sin(time * 2 + d.phase) * 3; 
                    d.displayY = d.y + floatingY; 
                    return `translate(${d.x}, ${d.displayY})`;
                });
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.displayY || d.source.y) 
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.displayY || d.target.y);
            });
            
            simulation.nodes(dataset.nodes);
            simulation.force("link").links(dataset.links);
            simulation.alpha(1).restart();
        }

        function openModal(node) {
            selectedNode = node;
            document.getElementById("inputModal").style.display = "flex";
            document.getElementById("commentInput").focus();
        }

        function closeModal() {
            document.getElementById("inputModal").style.display = "none";
            document.getElementById("commentInput").value = "";
            selectedNode = null;
        }

        function submitComment() {
            const text = document.getElementById("commentInput").value;
            if (!text) return alert("내용을 입력해주세요.");

            const newId = "node-" + Date.now();
            const newNode = {
                id: newId,
                label: text,
                color: "#ffffff",
                radius: 50, // 넉넉한 초기 크기
                x: selectedNode.x + (Math.random() - 0.5) * 50,
                y: selectedNode.y + (Math.random() - 0.5) * 50,
                phase: Math.random() * Math.PI * 2
            };

            dataset.nodes.push(newNode);
            dataset.links.push({ source: selectedNode.id, target: newId });

            if (selectedNode.radius < 200) {
                selectedNode.radius += 8; 
            }

            closeModal();
            update();
        }

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        document.getElementById("commentInput").addEventListener("keyup", function(event) {
            if (event.key === "Enter") submitComment();
        });

        update();
    </script>
</body>
</html>